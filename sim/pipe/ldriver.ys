#######################################################################
# Test for copying block of size 63;
#######################################################################
	.pos 0
main:	irmovq Stack, %rsp  	# Set up stack pointer

	# Set up arguments for copy function and then invoke it
	irmovq $63, %rdx		# src and dst have 63 elements
	irmovq dest, %rsi	# dst array
	irmovq src, %rdi	# src array
	call ncopy		 
	halt			# should halt with num nonzeros in %rax
StartFun:
#/* $begin ncopy-ys */
##################################################################
# ncopy.ys - Copy a src block of len words to dst.
# Return the number of positive words (>0) contained in src.
#
# Include your name and ID here.
#
# Author: Sum-Yuet Lee
# Date: 2024/5/22
#
# Describe how and why you modified the baseline code.
#
##################################################################
# Do not modify this portion
# Function prologue.
# %rdi = src, %rsi = dst, %rdx = len
ncopy:

##################################################################
# You can modify this portion
xorq %rax, %rax		        # count = 0;
iaddq $-8, %rdx             # %rdx < 8?
jl Remain                   # if so, goto Remain

Unroll:
Unroll_1:
mrmovq (%rdi), %r8      # read
rmmovq %r8, (%rsi)      # write
andq %r8, %r8		    # val <= 0?
jle Unroll_2		    # if so, goto next
iaddq $1, %rax          # count++

Unroll_2:
mrmovq 8(%rdi), %r9     # read
rmmovq %r9, 8(%rsi)     # write
andq %r9, %r9		    # val <= 0?
jle Unroll_3		    # if so, goto next
iaddq $1, %rax          # count++

Unroll_3:
mrmovq 16(%rdi), %r10   # read
rmmovq %r10, 16(%rsi)   # write
andq %r10, %r10		    # val <= 0?
jle Unroll_4		    # if so, goto next
iaddq $1, %rax          # count++

Unroll_4:
mrmovq 24(%rdi), %r11   # read
rmmovq %r11, 24(%rsi)   # write
andq %r11, %r11		    # val <= 0?
jle Unroll_5            # if so, goto next
iaddq $1, %rax          # count++

Unroll_5:
mrmovq 32(%rdi), %r12   # read
rmmovq %r12, 32(%rsi)   # write
andq %r12, %r12 	    # val <= 0?
jle Unroll_6	        # if so, goto next
iaddq $1, %rax          # count++

Unroll_6:
mrmovq 40(%rdi), %r13   # read
rmmovq %r13, 40(%rsi)   # write
andq %r13, %r13		    # val <= 0?
jle Unroll_7        	# if so, goto next
iaddq $1, %rax          # count++

Unroll_7:
mrmovq 48(%rdi), %r14   # read
rmmovq %r14, 48(%rsi)   # write
andq %r14, %r14		    # val <= 0?
jle Unroll_8            # if so, goto next
iaddq $1, %rax          # count++

Unroll_8:
mrmovq 56(%rdi), %rbx   # read
rmmovq %rbx, 56(%rsi)   # write
andq %rbx, %rbx		    # val <= 0?
jle Update		        # if so, goto Update
iaddq $1, %rax          # count++

Update:
# Increment src and dst
iaddq $64, %rdi
iaddq $64, %rsi
iaddq $-8, %rdx         # len >= 8? (now %rdx = len - 8)
jge Unroll              # if so, keep unrolling

# Deal with remaining data
Remain:
iaddq $8, %rdx          # now %rdx = len
je Done                 # if len == 0, done
iaddq $-1, %rdx
je Remain_1             # if len == 1
iaddq $-1, %rdx
je Remain_2             # if len == 2
iaddq $-1, %rdx
je Remain_3             # if len == 3
iaddq $-1, %rdx
je Remain_4             # if len == 4
iaddq $-1, %rdx
je Remain_5             # if len == 5
iaddq $-1, %rdx
je Remain_6             # if len == 6

Remain_7:
mrmovq 48(%rdi), %r14   # read
rmmovq %r14, 48(%rsi)   # write
andq %r14, %r14
jle Remain_6
iaddq $1, %rax

Remain_6:
mrmovq 40(%rdi), %r13   # read
rmmovq %r13, 40(%rsi)   # write
andq %r13, %r13
jle Remain_5
iaddq $1, %rax

Remain_5:
mrmovq 32(%rdi), %r12   # read
rmmovq %r12, 32(%rsi)   # write
andq %r12, %r12
jle Remain_4
iaddq $1, %rax

Remain_4: 
mrmovq 24(%rdi), %r11   # read
rmmovq %r11, 24(%rsi)   # write
andq %r11, %r11
jle Remain_3
iaddq $1, %rax

Remain_3:  
mrmovq 16(%rdi), %r10   # read
rmmovq %r10, 16(%rsi)   # write
andq %r10, %r10
jle Remain_2
iaddq $1, %rax

Remain_2:  
mrmovq 8(%rdi), %r9     # read
rmmovq %r9, 8(%rsi)     # write
andq %r9, %r9
jle Remain_1
iaddq $1, %rax

Remain_1:  
mrmovq (%rdi), %r8      # read
rmmovq %r8, (%rsi)      # write
andq %r8, %r8
jle Done
iaddq $1, %rax

##################################################################
# Do not modify the following section of code
# Function epilogue.
Done:
ret
##################################################################
# Keep the following label at the end of your function
End:
#/* $end ncopy-ys */
EndFun:

###############################
# Source and destination blocks 
###############################
	.align 8
src:
	.quad 1
	.quad -2
	.quad -3
	.quad 4
	.quad -5
	.quad -6
	.quad 7
	.quad 8
	.quad 9
	.quad 10
	.quad -11
	.quad 12
	.quad 13
	.quad -14
	.quad 15
	.quad -16
	.quad 17
	.quad -18
	.quad 19
	.quad 20
	.quad -21
	.quad -22
	.quad -23
	.quad 24
	.quad -25
	.quad 26
	.quad -27
	.quad 28
	.quad -29
	.quad 30
	.quad 31
	.quad 32
	.quad 33
	.quad 34
	.quad 35
	.quad 36
	.quad -37
	.quad -38
	.quad 39
	.quad 40
	.quad 41
	.quad -42
	.quad 43
	.quad 44
	.quad -45
	.quad 46
	.quad 47
	.quad 48
	.quad 49
	.quad -50
	.quad -51
	.quad -52
	.quad -53
	.quad -54
	.quad -55
	.quad -56
	.quad -57
	.quad -58
	.quad -59
	.quad -60
	.quad -61
	.quad -62
	.quad -63
	.quad 0xbcdefa # This shouldn't get moved

	.align 16
Predest:
	.quad 0xbcdefa
dest:
	.quad 0xcdefab
	.quad 0xcdefab
	.quad 0xcdefab
	.quad 0xcdefab
	.quad 0xcdefab
	.quad 0xcdefab
	.quad 0xcdefab
	.quad 0xcdefab
	.quad 0xcdefab
	.quad 0xcdefab
	.quad 0xcdefab
	.quad 0xcdefab
	.quad 0xcdefab
	.quad 0xcdefab
	.quad 0xcdefab
	.quad 0xcdefab
	.quad 0xcdefab
	.quad 0xcdefab
	.quad 0xcdefab
	.quad 0xcdefab
	.quad 0xcdefab
	.quad 0xcdefab
	.quad 0xcdefab
	.quad 0xcdefab
	.quad 0xcdefab
	.quad 0xcdefab
	.quad 0xcdefab
	.quad 0xcdefab
	.quad 0xcdefab
	.quad 0xcdefab
	.quad 0xcdefab
	.quad 0xcdefab
	.quad 0xcdefab
	.quad 0xcdefab
	.quad 0xcdefab
	.quad 0xcdefab
	.quad 0xcdefab
	.quad 0xcdefab
	.quad 0xcdefab
	.quad 0xcdefab
	.quad 0xcdefab
	.quad 0xcdefab
	.quad 0xcdefab
	.quad 0xcdefab
	.quad 0xcdefab
	.quad 0xcdefab
	.quad 0xcdefab
	.quad 0xcdefab
	.quad 0xcdefab
	.quad 0xcdefab
	.quad 0xcdefab
	.quad 0xcdefab
	.quad 0xcdefab
	.quad 0xcdefab
	.quad 0xcdefab
	.quad 0xcdefab
	.quad 0xcdefab
	.quad 0xcdefab
	.quad 0xcdefab
	.quad 0xcdefab
	.quad 0xcdefab
	.quad 0xcdefab
	.quad 0xcdefab
Postdest:
	.quad 0xdefabc

.align 8
# Run time stack
	.quad 0
	.quad 0
	.quad 0
	.quad 0
	.quad 0
	.quad 0
	.quad 0
	.quad 0
	.quad 0
	.quad 0
	.quad 0
	.quad 0
	.quad 0
	.quad 0
	.quad 0
	.quad 0

Stack:
